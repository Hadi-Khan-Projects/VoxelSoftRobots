# results_analyzer.py

import ast
import glob
import math
import os
import traceback

import matplotlib.pyplot as plt
import mujoco  # Needed by simulate/rerun indirectly
import numpy as np
import pandas as pd

from controller import DistributedNeuralController  # Needed for simulation call
from simulate import run_simulation  # Direct simulation call might be needed

# Imports from your project
from vsr import VoxelRobot

# Attempt to import the rerun function - adjust path if needed
try:
    from rerun import rerun_simulation_from_log

    RERUN_AVAILABLE = True
except ImportError:
    print("Warning: Could not import rerun_simulation_from_log from rerun.py.")
    print(
        "         The 'rerun_specific_simulation' method using the external script will not work."
    )
    RERUN_AVAILABLE = False


class Results:
    """
    Analyzes and visualizes results from VSR evolution runs generated by evolve.py.
    """

    def __init__(
        self, run_name: str, vsr_grid_dims: tuple = (10, 10, 10), default_gear=150.0
    ):
        """
        Initializes the Results analyzer.

        Args:
            run_name (str): The path to the evolution run directory
                            (e.g., 'evolution_results/co_evolve_4x2x2_YYYYMMDD-HHMMSS').
            vsr_grid_dims (tuple): The (x, y, z) grid dimensions used during the run.
            default_gear (float): Default gear ratio to use when loading VSRs
                                  (visualisation doesn't need exact gear, but VoxelRobot requires it).
        """
        self.run_name = run_name
        self.vsr_grid_dims = vsr_grid_dims
        self.default_gear = default_gear
        self.full_history_df = None
        self.batch_history_dfs = {}  # Cache for loaded batch histories

        if not os.path.isdir(self.run_name):
            raise FileNotFoundError(f"Run directory not found: {self.run_name}")

        self.paths = {
            "initial_model_dir": os.path.join(self.run_name, "initial_model"),
            "best_overall_csv": os.path.join(
                self.run_name, "best_overall_morphology.csv"
            ),
            "full_history_csv": os.path.join(
                self.run_name, "full_evolution_history.csv"
            ),
            "models_dir": os.path.join(self.run_name, "models"),
        }

        # Try loading full history on init
        try:
            if os.path.exists(self.paths["full_history_csv"]):
                self.full_history_df = pd.read_csv(self.paths["full_history_csv"])
                print(f"Loaded full history with {len(self.full_history_df)} records.")
            else:
                print(
                    f"Warning: Full history file not found at {self.paths['full_history_csv']}"
                )
        except Exception as e:
            print(f"Error loading full history CSV: {e}")

    # --- Helper Methods ---

    def _find_initial_model_csv(self):
        """Finds the initial model CSV file."""
        try:
            csv_files = glob.glob(
                os.path.join(self.paths["initial_model_dir"], "*.csv")
            )
            if not csv_files:
                print(
                    f"Error: No initial model CSV found in {self.paths['initial_model_dir']}"
                )
                return None
            # Assuming only one initial model file
            return csv_files[0]
        except Exception as e:
            print(f"Error finding initial model CSV: {e}")
            return None

    def _get_mutation_csv_path(self, batch_num, mut_num):
        """Constructs the path to a specific mutation's CSV file."""
        mutation_id = f"batch{batch_num}_mut{mut_num}"
        return os.path.join(self.paths["models_dir"], mutation_id, f"{mutation_id}.csv")

    def _load_vsr_from_csv(self, csv_path):
        """Loads a VoxelRobot instance from a given CSV file path."""
        if not os.path.exists(csv_path):
            print(f"Error: VSR structure file not found: {csv_path}")
            return None
        try:
            vsr = VoxelRobot(*self.vsr_grid_dims, gear=self.default_gear)
            vsr.load_model_csv(csv_path)
            # Optional: Validate contiguity?
            # vsr._check_contiguous()
            return vsr
        except Exception as e:
            print(f"Error loading VSR from {csv_path}: {e}")
            # print(traceback.format_exc())
            return None

    def _load_batch_history(self, batch_num):
        """Loads (or retrieves from cache) the history CSV for a specific batch."""
        if batch_num in self.batch_history_dfs:
            return self.batch_history_dfs[batch_num]

        batch_csv_path = os.path.join(self.run_name, f"batch_{batch_num}_history.csv")
        if not os.path.exists(batch_csv_path):
            print(f"Error: Batch history file not found: {batch_csv_path}")
            return None
        try:
            df = pd.read_csv(batch_csv_path)
            self.batch_history_dfs[batch_num] = df
            print(f"Loaded history for batch {batch_num} ({len(df)} records).")
            return df
        except Exception as e:
            print(f"Error loading batch {batch_num} history CSV: {e}")
            return None

    def _plot_multiple_vsrs(
        self, vsr_list, titles=None, grid_cols=None, main_title=None
    ):
        """Helper to plot multiple VSRs in a grid."""
        if not vsr_list:
            print("No VSRs provided for plotting.")
            return

        num_vsrs = len(vsr_list)
        if grid_cols is None:
            grid_cols = math.ceil(math.sqrt(num_vsrs))
        grid_rows = math.ceil(num_vsrs / grid_cols)

        fig, axes = plt.subplots(
            grid_rows,
            grid_cols,
            figsize=(grid_cols * 4, grid_rows * 4),
            subplot_kw={"projection": "3d"},
            squeeze=False,
        )
        axes_flat = axes.flatten()

        for i, vsr in enumerate(vsr_list):
            if vsr is None:
                axes_flat[i].set_title("Load Error" if titles else "")
                axes_flat[i].axis("off")
                continue

            ax = axes_flat[i]
            x_coords, y_coords, z_coords = np.where(vsr.voxel_grid == 1)
            voxel_plot_size = 0.9

            # Plot each voxel as small cube
            for xi, yi, zi in zip(x_coords, y_coords, z_coords):
                ax.bar3d(
                    xi - voxel_plot_size / 2,
                    yi - voxel_plot_size / 2,
                    zi - voxel_plot_size / 2,
                    voxel_plot_size,
                    voxel_plot_size,
                    voxel_plot_size,
                    color="red",
                    alpha=0.6,
                )

            # Use grid dims for limits
            ax.set_xlim(0, self.vsr_grid_dims[0])
            ax.set_ylim(0, self.vsr_grid_dims[1])
            ax.set_zlim(0, self.vsr_grid_dims[2])
            ax.set_xlabel("X")
            ax.set_ylabel("Y")
            ax.set_zlabel("Z")
            ax.set_xticks(
                np.arange(
                    0, self.vsr_grid_dims[0] + 1, max(1, self.vsr_grid_dims[0] // 5)
                )
            )
            ax.set_yticks(
                np.arange(
                    0, self.vsr_grid_dims[1] + 1, max(1, self.vsr_grid_dims[1] // 5)
                )
            )
            ax.set_zticks(
                np.arange(
                    0, self.vsr_grid_dims[2] + 1, max(1, self.vsr_grid_dims[2] // 5)
                )
            )

            if titles and i < len(titles):
                ax.set_title(titles[i], fontsize=10)

        # Hide unused subplots
        for j in range(num_vsrs, len(axes_flat)):
            axes_flat[j].axis("off")

        if main_title:
            fig.suptitle(main_title, fontsize=16)

        plt.tight_layout(
            rect=[0, 0.03, 1, 0.95] if main_title else None
        )  # Adjust layout if title exists
        plt.show()

    # --- Public Methods ---

    def visualise_initial_vsr(self):
        """Visualizes the initial VSR morphology used for the run."""
        print("Visualizing Initial VSR...")
        initial_csv = self._find_initial_model_csv()
        if initial_csv:
            vsr = self._load_vsr_from_csv(initial_csv)
            if vsr:
                vsr.visualise_model()
                plt.title(f"Initial VSR Morphology\n({self.run_name})")
                plt.show()

    def visualise_best_overall_vsr(self):
        """Visualizes the best overall VSR morphology found during the run."""
        print("Visualizing Best Overall VSR...")
        if os.path.exists(self.paths["best_overall_csv"]):
            vsr = self._load_vsr_from_csv(self.paths["best_overall_csv"])
            if vsr:
                vsr.visualise_model()
                plt.title(f"Best Overall VSR Morphology\n({self.run_name})")
                plt.show()
        else:
            print(
                f"Error: Best overall morphology file not found: {self.paths['best_overall_csv']}"
            )

    def visualise_batch_mutation_vsr(self, batch_num: int, mut_num: int):
        """Visualizes the morphology of a specific mutation from a specific batch."""
        print(f"Visualizing VSR for Batch {batch_num}, Mutation {mut_num}...")
        csv_path = self._get_mutation_csv_path(batch_num, mut_num)
        vsr = self._load_vsr_from_csv(csv_path)
        if vsr:
            vsr.visualise_model()
            plt.title(f"Batch {batch_num}, Mutation {mut_num}\n({self.run_name})")
            plt.show()

    def visualise_batch_vsrs(self, batch_num: int):
        """Visualizes all mutation morphologies from a specific batch in a grid."""
        print(f"Visualizing all VSRs for Batch {batch_num}...")
        batch_dir = os.path.join(self.paths["models_dir"])
        mutation_dirs = sorted(
            glob.glob(os.path.join(batch_dir, f"batch{batch_num}_mut*"))
        )

        if not mutation_dirs:
            print(f"Error: No mutation directories found for batch {batch_num}.")
            return

        vsrs_to_plot = []
        titles = []
        for mut_dir in mutation_dirs:
            try:
                # Extract mutation number from directory name
                mut_id_str = os.path.basename(mut_dir)  # e.g., batch1_mut5
                mut_num = int(mut_id_str.split("_mut")[-1])
                csv_path = os.path.join(mut_dir, f"{mut_id_str}.csv")
                vsr = self._load_vsr_from_csv(csv_path)
                vsrs_to_plot.append(vsr)  # Add vsr even if None, plotting handles it
                titles.append(f"Mut {mut_num}")
            except Exception as e:
                print(f"Error processing directory {mut_dir}: {e}")
                vsrs_to_plot.append(None)
                titles.append("Load Error")

        self._plot_multiple_vsrs(
            vsrs_to_plot, titles, main_title=f"VSR Morphologies for Batch {batch_num}"
        )

    def rerun_specific_simulation(
        self,
        batch_num: int,
        mut_num: int,
        generation_num: int,
        individual_idx: int,
        duration: int = 60,
        headless: bool = False,
    ):
        """
        Reruns the simulation for a specific individual from a specific mutation and batch.
        This method reconstructs the state and calls simulate.run_simulation directly.
        """
        print(
            f"\n--- Rerunning Simulation for Batch {batch_num}, Mut {mut_num}, Gen {generation_num}, Idx {individual_idx} ---"
        )

        # 1. Load Batch History
        batch_df = self._load_batch_history(batch_num)
        if batch_df is None:
            return None

        # 2. Find the Specific Record
        try:
            target_row = batch_df[
                (batch_df["mutation_index"] == mut_num)
                & (batch_df["generation"] == generation_num)
                & (batch_df["individual_index"] == individual_idx)
            ]
            if target_row.empty:
                print("Error: Record not found in batch history.")
                return None
            record = target_row.iloc[0]
            print(f"Record found. Logged fitness: {record.get('fitness', 'N/A')}")
        except Exception as e:
            print(f"Error finding record: {e}")
            return None

        # 3. Extract Parameters from Record
        try:
            voxel_coords_str = record["voxel_coords_str"]
            params_vector_str = record[
                "params_vector_str"
            ]  # Note the column name change from rerun.py example
            control_timestep = record["control_timestep"]
            gear_ratio = record["gear_ratio"]
            controller_type = record["controller_type"]
            mlp_plus_str = record.get(
                "mlp_plus_hidden_sizes_str", "[]"
            )  # Use .get for safety
            rnn_hidden_size = record.get("rnn_hidden_size", 0)  # Use .get for safety

            voxel_coords_list = ast.literal_eval(voxel_coords_str)
            param_vector = np.array(
                ast.literal_eval(params_vector_str), dtype=np.float64
            )
            mlp_plus_hidden_sizes = (
                ast.literal_eval(mlp_plus_str) if controller_type == "mlp_plus" else []
            )
            rnn_hidden_size = int(rnn_hidden_size) if controller_type == "rnn" else 0

            print(f"  Controller Type: {controller_type}")
            if controller_type == "mlp_plus":
                print(f"  MLP+ Hidden: {mlp_plus_hidden_sizes}")
            if controller_type == "rnn":
                print(f"  RNN Hidden: {rnn_hidden_size}")

        except Exception as e:
            print(f"Error extracting/parsing parameters from record: {e}")
            return None

        # 4. Reconstruct VSR Model
        model = None
        xml_string = None
        temp_model_base = (
            f"temp_rerun_b{batch_num}_m{mut_num}_g{generation_num}_i{individual_idx}"
        )
        try:
            print("Reconstructing VSR model...")
            os.makedirs(
                os.path.dirname(temp_model_base), exist_ok=True
            )  # Ensure dir exists
            vsr_instance = VoxelRobot(*self.vsr_grid_dims, gear=gear_ratio)
            for x, y, z in voxel_coords_list:
                if (
                    0 <= x < vsr_instance.max_x
                    and 0 <= y < vsr_instance.max_y
                    and 0 <= z < vsr_instance.max_z
                ):
                    vsr_instance.set_val(x, y, z, 1)
            xml_string = vsr_instance.generate_model(temp_model_base)
            model = mujoco.MjModel.from_xml_string(xml_string)
            print("MuJoCo model reconstructed.")
        except Exception as e:
            print(f"Error during VSR reconstruction: {e}")
            return None

        # 5. Run Simulation Directly
        results = None
        try:
            print(f"Starting simulation rerun (Duration: {duration}s)...")
            results = run_simulation(
                model=model,
                duration=duration,
                control_timestep=control_timestep,
                param_vector=param_vector,  # Pass the vector directly
                controller_type=controller_type,
                mlp_plus_hidden_sizes=mlp_plus_hidden_sizes,
                rnn_hidden_size=rnn_hidden_size,
                headless=headless,
                # weights=None, biases=None # Ensure param_vector takes precedence
            )
            print("Simulation rerun finished.")
        except Exception as e:
            print(f"Error during simulation execution: {e}")
            print(traceback.format_exc())
            return None
        finally:
            # Clean up temporary model files
            modded_xml_path = temp_model_base + "_modded.xml"
            xml_path = temp_model_base + ".xml"
            try:
                if os.path.exists(modded_xml_path):
                    os.remove(modded_xml_path)
                if os.path.exists(xml_path):
                    os.remove(xml_path)
            except OSError as e_rem:
                print(f"Warning: Could not remove temporary model files: {e_rem}")

        return results

    def plot_batch_fitness_summary(self):
        """Plots the best and average fitness achieved in each batch."""
        if self.full_history_df is None:
            print("Error: Full history not loaded.")
            return

        print("Plotting batch fitness summary...")
        try:
            # Clean fitness data (replace -inf with NaN for calculations)
            fitness_cleaned = self.full_history_df["fitness"].replace(-np.inf, np.nan)
            df_cleaned = self.full_history_df.assign(fitness_cleaned=fitness_cleaned)

            # Group by batch and calculate max and mean (ignoring NaN)
            summary = (
                df_cleaned.groupby("batch")["fitness_cleaned"]
                .agg(["max", "mean"])
                .reset_index()
            )
            summary.rename(
                columns={"max": "Best Fitness", "mean": "Average Fitness"}, inplace=True
            )

            if summary.empty:
                print("No valid fitness data found across batches.")
                return

            plt.figure(figsize=(12, 6))
            plt.plot(
                summary["batch"],
                summary["Best Fitness"],
                marker="o",
                linestyle="-",
                label="Best Fitness per Batch",
            )
            plt.plot(
                summary["batch"],
                summary["Average Fitness"],
                marker="x",
                linestyle="--",
                label="Average Fitness per Batch",
            )

            plt.xlabel("Batch Number")
            plt.ylabel("Fitness")
            plt.title(f"Fitness Summary Across Batches\n({self.run_name})")
            plt.legend()
            plt.grid(True)
            plt.xticks(summary["batch"])  # Ensure ticks for each batch
            plt.show()

        except KeyError as e:
            print(f"Error: Missing required column in full history: {e}")
        except Exception as e:
            print(f"Error plotting batch fitness summary: {e}")

    def plot_mutation_fitness_history(self, batch_num: int, mut_num: int):
        """Plots the fitness history (best/avg per gen) for a specific mutation."""
        print(f"Plotting fitness history for Batch {batch_num}, Mutation {mut_num}...")
        batch_df = self._load_batch_history(batch_num)
        if batch_df is None:
            return

        try:
            mutation_df = batch_df[
                batch_df["mutation_index"] == mut_num
            ].copy()  # Use copy to avoid SettingWithCopyWarning
            if mutation_df.empty:
                print(
                    f"Error: No data found for mutation {mut_num} in batch {batch_num}."
                )
                return

            # Clean fitness data
            mutation_df["fitness_cleaned"] = mutation_df["fitness"].replace(
                -np.inf, np.nan
            )

            # Group by generation
            gen_summary = (
                mutation_df.groupby("generation")["fitness_cleaned"]
                .agg(["max", "mean"])
                .reset_index()
            )
            gen_summary.rename(
                columns={"max": "Best Fitness", "mean": "Average Fitness"}, inplace=True
            )

            plt.figure(figsize=(10, 5))
            plt.plot(
                gen_summary["generation"],
                gen_summary["Best Fitness"],
                marker="o",
                linestyle="-",
                label="Best Fitness per Generation",
            )
            plt.plot(
                gen_summary["generation"],
                gen_summary["Average Fitness"],
                marker="x",
                linestyle="--",
                label="Average Fitness per Generation",
            )

            plt.xlabel("Generation Number (within Optimisation)")
            plt.ylabel("Fitness")
            plt.title(
                f"Fitness History for Batch {batch_num}, Mutation {mut_num}\n({self.run_name})"
            )
            plt.legend()
            plt.grid(True)
            plt.xticks(gen_summary["generation"])
            plt.show()

        except KeyError as e:
            print(f"Error: Missing required column in batch history: {e}")
        except Exception as e:
            print(f"Error plotting mutation fitness history: {e}")

    def visualise_top_batch_performers(self, top_n: int = 3):
        """
        Visualizes the morphologies of the top N performing mutations from each batch.
        """
        if self.full_history_df is None:
            print("Error: Full history not loaded.")
            return

        print(f"Visualizing Top {top_n} VSRs per Batch...")
        try:
            batches = sorted(self.full_history_df["batch"].unique())
            if not batches:
                print("No batches found in history.")
                return

            vsrs_to_plot = []
            titles = []
            num_batches = len(batches)

            for rank in range(
                top_n
            ):  # Iterate through ranks (0=best, 1=2nd best, etc.)
                for batch_num in batches:
                    batch_df = self.full_history_df[
                        self.full_history_df["batch"] == batch_num
                    ]

                    # Find unique mutations and their max fitness within this batch
                    mutation_best_fitness = batch_df.groupby("mutation_index")[
                        "fitness"
                    ].max()

                    # Sort mutations by their best fitness, descending
                    sorted_mutations = mutation_best_fitness.sort_values(
                        ascending=False
                    )

                    title = f"Batch {batch_num}\nRank {rank + 1}"
                    vsr = None

                    if rank < len(sorted_mutations):
                        top_mut_idx = sorted_mutations.index[rank]
                        top_mut_fit = sorted_mutations.iloc[rank]

                        # Only proceed if fitness is valid
                        if np.isfinite(top_mut_fit) and top_mut_fit > -np.inf:
                            csv_path = self._get_mutation_csv_path(
                                batch_num, top_mut_idx
                            )
                            vsr = self._load_vsr_from_csv(csv_path)
                            title += f"\nMut {top_mut_idx}\nFit: {top_mut_fit:.2f}"
                        else:
                            title += "\n(N/A or -inf)"
                    else:
                        title += "\n(N/A)"  # Not enough mutations for this rank

                    vsrs_to_plot.append(vsr)
                    titles.append(title)

            if not vsrs_to_plot:
                print("Could not find any top performers to visualize.")
                return

            # Plot in a grid (top_n rows, num_batches columns)
            self._plot_multiple_vsrs(
                vsrs_to_plot,
                titles,
                grid_cols=num_batches,
                main_title=f"Top {top_n} Performing VSR Morphologies per Batch",
            )

        except KeyError as e:
            print(f"Error: Missing required column in full history: {e}")
        except Exception as e:
            print(f"Error visualizing top batch performers: {e}")
            print(traceback.format_exc())


# --- Example Usage ---
if __name__ == "__main__":
    # --- !!! IMPORTANT: SET THIS TO YOUR ACTUAL RUN DIRECTORY !!! ---
    # Find the latest run directory automatically (example)
    try:
        evolution_dirs = glob.glob("evolution_results/co_evolve_*")
        if not evolution_dirs:
            raise FileNotFoundError("No evolution result directories found.")
        latest_run_dir = max(evolution_dirs, key=os.path.getmtime)
        RUN_NAME = latest_run_dir
        print(f"Using latest run directory: {RUN_NAME}")
    except FileNotFoundError as e:
        print(e)
        # RUN_NAME = "evolution_results/co_evolve_4x2x2_YYYYMMDD-HHMMSS" # Set manually if needed
        RUN_NAME = None  # Force exit if no runs found

    if RUN_NAME and os.path.isdir(RUN_NAME):
        results = Results(run_name=RUN_NAME)  # Assuming grid dims (10,10,10)

        # --- Select actions to perform ---
        DO_VIS_INITIAL = True
        DO_VIS_BEST = True
        DO_VIS_SPECIFIC_MUT = True  # Requires setting batch/mut numbers below
        DO_VIS_BATCH = True  # Requires setting batch number below
        DO_RERUN = False  # Requires setting batch/mut/gen/idx below
        DO_PLOT_BATCH_SUMMARY = True
        DO_PLOT_MUT_HISTORY = True  # Requires setting batch/mut numbers below
        DO_VIS_TOP_PERFORMERS = True

        # --- Parameters for specific actions ---
        TARGET_BATCH = 1
        TARGET_MUTATION = 1
        TARGET_GENERATION = 2  # 1-based
        TARGET_INDIVIDUAL = 0  # 0-based
        RERUN_DURATION = 60  # Seconds
        RERUN_HEADLESS = False

        # --- Execute selected actions ---
        if DO_VIS_INITIAL:
            results.visualise_initial_vsr()

        if DO_VIS_BEST:
            results.visualise_best_overall_vsr()

        if DO_VIS_SPECIFIC_MUT:
            results.visualise_batch_mutation_vsr(TARGET_BATCH, TARGET_MUTATION)

        if DO_VIS_BATCH:
            results.visualise_batch_vsrs(TARGET_BATCH)

        if DO_RERUN:
            rerun_result_data = results.rerun_specific_simulation(
                TARGET_BATCH,
                TARGET_MUTATION,
                TARGET_GENERATION,
                TARGET_INDIVIDUAL,
                duration=RERUN_DURATION,
                headless=RERUN_HEADLESS,
            )
            if rerun_result_data:
                print("\nRerun Results:", rerun_result_data)
            else:
                print("\nRerun failed.")

        if DO_PLOT_BATCH_SUMMARY:
            results.plot_batch_fitness_summary()

        if DO_PLOT_MUT_HISTORY:
            results.plot_mutation_fitness_history(TARGET_BATCH, TARGET_MUTATION)

        if DO_VIS_TOP_PERFORMERS:
            results.visualise_top_batch_performers(top_n=3)  # Visualize top 3 per batch

    else:
        print(f"Run directory not found or not specified: {RUN_NAME}")
